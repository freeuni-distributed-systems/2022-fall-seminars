1. what to do
	* do go tutor
	* check out go by example
2. why go?
	* threads & RPC good
	* GC
	* type safe
	* simple
	* compiled/fast
	* I don like it
3. go thread:
	* PC, stack, registers
	* shared memory
	* each thread is sequntial
	* go runtime
	* pause/resume thread
4. Why threads?
	* I/O concurency / async
	* multi-core paralellism
	* convenience
5. How many threads?
6. Challenges
	* race conditions
		* n=n+1 example
	* avoid sharing/channels
	* use locks
	* go race detector
	* deadlocks
7. solutions:
	* channels (no sharing)
	* locks (sharing)
	* do it per case
8. voting
9. crawler
10. RPC
	* as similar to local call
	* server <--call/result--> client
	* stub marshal/unmarshal
	* autogenerated
11. RPC semantics:
	* at least once -- DUPLICATION
	* at most once -- DROPS -- GO (OURS) / ERR
	* exactly once -- IDEALLY


last lecture lies:
* to make a type public it needs to start with big letter lol


